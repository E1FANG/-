# 哈希表

数据结构是组织和存储数据的一种方式。

数据通常是对现实世界的一种抽象，那么现实世界的物体无穷无尽，如何在有限的空间中存储无限的物体？这就需要映射了，用有限的集合去映射无限的集合，哈希表就是这样去组织和存储数据的。

&nbsp;

哈希表，简单来说就是键值对，用key去映射value，实现高效的对元素的查找。输入key去查找并获取value，时间复杂度为O(1)

![](https://media.heptabase.com/v1/images/e270dfa5-22d1-4da0-8afe-51e6c1377369/e0dbd355-6775-4c9c-8b11-3dc801088fc1/image.png)&nbsp;

如上图，无论是查找还是增删元素，哈希表的时间复杂度都是O(1)

&nbsp;

在js中，对象就是哈希表，属性名称就是哈希表的key，属性的值就是哈希表的value。

也带有哈希表的常规操作，初始话、查询、增删键值对、遍历哈希表

```javascript
  // init
  const map = {}

  // add
  map.first = 'hi'
  Reflect.set(map, 'first', 'hi reflect')

  // delete 
  delete map.first
  Reflect.deleteProperty(map, 'first')

  // 遍历
  Object.keys(map).forEach(e => console.log(map[e]))

  Reflect.ownKeys(map).forEach(e => console.log(map[e]))

  for (const [key, value] of Object.entries(map)) {
    console.log(key, value)
  }
```

## 哈希函数

哈希表存储元素的数据结构叫[ 桶（bucket）](./%E6%A1%B6%2071d85712-02de-400f-905e-9093f36d58a4.md "!桶")，它的底层实现可能是数组、链表、二叉树（红黑树）或它们的组合。

&nbsp;

我们使用简单的数组来实现哈希表：把所有value进数组里面，那么每个value在数组中就有唯一的索引。要访问value就需要对应的下标，而为了建立key和索引之间的映射关系

&nbsp;

key和索引的关系：索引\=哈希函数(key)

![](https://media.heptabase.com/v1/images/e270dfa5-22d1-4da0-8afe-51e6c1377369/df6ad1cd-694c-4068-96c4-5fba77a5571e/image.png#center =100%x)哈希函数是帮助我们使用key寻址的，桶一般是使用数组实现的，我们使用哈希函数去转化key，得到存value的数组索引。这样我们提取value的复杂度就是O(1)了。

哈希函数是为了解决在有限的数组索引范围内，提供几乎不会重复的key转化索引的结果。

Q：为什么是有限的数组索引范围？

A：如果不限制数组的大小，数组占用的内存又是固定的，那么一个哈希表所占据的内存就太大了。

---

Q：几乎不会重复？

A：这是在取舍中得来的结果。使用不会重复的哈希函数方法，要容纳的东西实在太多了，代价是数组太大，而且数组利用率不高，会有无效项。

(数组太长，key的转化并不能填满每一个下标，比如\[fira,firb,firc,fird,fire,firf\] 这个数组，我们要存所有的英文单词的话，起码firc,firb等是无效的（哈希算法是会给firc，firb留位置的，但是英文单词中并没有这两个单词，所以内存上是空的）

---

Q：那重复了怎么办？数组的一个下标总不能存多个value吧

A：这就引出了接下来要说到的哈希冲突

&nbsp;

## 哈希冲突

哈希函数是固定的key输入，得到固定的数组index输出。但是不同的key输入，有可能转换出相同的index，这就是哈希冲突。

&nbsp;

## 如何解决哈希冲突

有两种方法：

### 链式法

数组冲突的索引项，不再只保存value，而是保存一个链表(或数组)，当发生冲突时，把vlaue插入到链表的前端或者末端(放前端的话，一般是后来的数据是经常会使用到的做法，比较能快速能拿到)，而且冲突的数量一般不会很多，2-4个左右，所以虽然要循环链表逐一对比去拿到匹配的值，复杂度是oOn)，但链比较短，依然可以视为O(1)

### 开放寻址法

该方法主要是通过寻找空白的单元格来放置冲突的数据。

就像上面提到的英文单词，实际上firb,firc就是空白的，当有与fire冲突的index进来，就会放到这些位置上。

这种方法有三种实现方式，区别就是它们在数组上寻找空白单元格的步长。

1. 线性探测

2. 二次探测

3. 再哈希法

---

**线性探测**

步长为1的探测法，意思是当发生冲突时，在冲突位置index\+1为空白时，放置元素。若不为空白，index再加一。

我们假设哈希函数为取模函数。那么32和62即为冲突。62就会保存在32下标的后一位。

缺点：会发生聚集，比如现有数据下标为22，23，24，25，26，那么当我存32时，就会从22往下\+1探测，一直到27的位置才到空白位置保存。可见这样的聚集会引发多次探测，会影响哈希表的性能。

聚集：一连串的填充单元就叫做聚集

---

**二次探测**

二次探测可以解决线性探测的部分问题

线性探测是步长为1的探测，比如从x下标开始探测，他的表现就是：x\+1,x\+2,x\+3依次探测。

二次探测则是对步长做了优化：x\+1²，x\+2²，x\+3²，依次探测。

它就是增大了一次探测的范围，避免了一定程度上的聚集。

缺点：但是如果是连续插入32-112-82这样的数据，依然还是会产生聚集，只是这样的连续插入相较于22,23,24,25这样的连续插入比较少见。其实也是一种步长不一的聚集。

怎么根本解决这个问题？让每次插入的步长不一样即可，这就是再哈希法

---

**再哈希法**

当发生冲突时，把key用另外一个哈希函数，在做一次哈希化，用这一次的哈希化结果作为步长。

第二次哈希化需要具备以下特点：

1. 和第一次哈希函数是不一样的。

2. 不能输出0（否则得出的步长为0，每次探测都是原地踏步，进入死循环）

* 计算机专家已经给出了很好的哈希函数

  * stepSize \= constant - (key % constant)

  * constant 是质数，小于数组的容量

  * 该函数结果不可能为0

需要准备多个哈希函数，来进行多次哈希化

## 哈希化效率与填装因子

填装因子 \= 总数据项 / 哈希表长度（数组长度）

开放寻址的填装因子最大是 1 

链地址法的填装因子最大是可以超过1的

开放寻址是在数组范围内寻找空白的地址，只会有空白处(<1)，而不会超出数组(>1)

链地址法是可以通过链无限延伸下去的，所以可以大于数组长度。

&nbsp;

**填装因子与效率的关系**

**开放寻址法的效率**

可以看到的是在填装因子越大，效率就越低下，甚至是指数级的低下。

填装因子越大，数组的空白就越少，找到空白所需要执行的哈希化次数就越多，效率就越低下

&nbsp;

![](https://media.heptabase.com/v1/images/e270dfa5-22d1-4da0-8afe-51e6c1377369/7e212df4-3eb9-47b3-95aa-920fc052f457/image.png#center =20%x)**链地址法的效率**

同样，在填装因子越大，效率就越低下，这是肯定的。

但是链式地址法是线性的低下。

要么走完整条链，没找到。

要么走一半，找到了。

数据越大，链越长，找的越久，多么得线性。即使填装因子超出1。

![](https://media.heptabase.com/v1/images/e270dfa5-22d1-4da0-8afe-51e6c1377369/4e337ac9-e3e7-4047-85c2-69b26959ae2b/image.png#center =50%x)